### 2.3.2 Example: Symbolic Differentiation



*outline* 

[TOC]



为了进一步说明 symbol manipulation，设计一个 procedure，求导 代数表达式。如，给参数 $ax^2 + bx +c, x$ 得到 $2ax + b$ 。

在开发求导程序的过程中，我们会使用 2.1.1 节中开发有理数系统的策略。首先定义操作 abstract object 的算法，如 sum，products 和 variables，且不考虑这些算法的实际实现，直到我们需要实现它为止。



#### The differentiation program with abstract data

$$
\frac {dc} {dx} = 0
$$

$$
\frac {dx} {dx}= 1
$$

$$
\frac {d(u+v)} {dx} = \frac {du} {dx} + \frac {dv} {dx}
$$

$$
\frac {d(uv)} {dx} = u(\frac {dv} {dx}) + v(\frac {du} {dx})
$$

如对 sum 求导，需要将每一项分解为更小的部分，最终分解为一个常数或变量，其导数为 0 或 1。

要体现上面的规则，我们需要判断代数表达式本身是否 sum，product，constant 或 variable。我们需要能够提取表达式的项，如 sum，我们需要提取其 addend 和 augend。

假设已有 procedure 实现了下面的 selectors，constructors 和 predicates。

```lisp
(variable? e)             ; e 是否变量
(same-variable? v1 v2)    ; v1 v2 是同一个变量
(sum? e)                  ; e 是一个 sum
(addend e)                ; e 的加数
(augend e)                ; e 的被加数
(make-sum a1 a2)          ; 构造 a1 a2 的和
(product? e)              ; e 是一个 product
(multiplier e)            ; e 的乘数
(multiplicand e)          ; e 的被乘数
(make-product m1 m2)      ; 构造 m1 m2 的乘积
```



加上 number? 我们可以得到求导 procedure

```lisp
(define (deriv exp var)
  (cond ((number? exp) 0)
    ((variable? exp)
     (if (same-variable? exp var) 1 0))
    ((sum? exp)
     (make-sum (deriv (addend exp) var)
               (deriv (augend exp) var)))
    ((product? exp)
     (make-sum
      (make-product (multiplier exp)
                    (deriv (multiplicand exp) var))
      (make-product (deriv (multiplier exp) var)
                    (multiplicand exp))))
    (else
     (error "unknown expression type -- DERIV" exp))))
```



#### Representing algebraic expressions



表示代数表达式的两种方法

1. 表示 $ax + b$ 为 `(a * x + b)`
2. 表示 $ax + b$ 为 `(+ (* a x))`



求导问题中的数据表达

```lisp
(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (make-sum a1 a2) (list '+ a1 a2))
(define (make-product m1 m2) (list '* m1 m2))

(define (sum? x)
  (and (pair? x) (eq? (car x) 'x)))

(define (addend s) (cadr s))
(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p) (cadr p))

(define (multiplicand p) (caddr p))
```



```lisp
(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)

; '(+ 1 0)
; '(+ (* x 0) (* 1 y))
; '(+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))
```



简化结果

```lisp
(define (make-sum2 a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-product2 m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (deriv2 exp var)
  (cond ((number? exp) 0)
    ((variable? exp)
     (if (same-variable? exp var) 1 0))
    ((sum? exp)
     (make-sum2 (deriv2 (addend exp) var)
                (deriv2 (augend exp) var)))
    ((product? exp)
     (make-sum2
      (make-product2 (multiplier exp)
                     (deriv2 (multiplicand exp) var))
      (make-product2 (deriv2 (multiplier exp) var)
                     (multiplicand exp))))
    (else
     (error "unknown expression type -- DERIV" exp))))

(deriv2 '(+ x 3) 'x)
(deriv2 '(* x y) 'x)
(deriv2 '(* (* x y) (+ x 3)) 'x)

; 1
; 'y
; '(+ (* x y) (* y (+ x 3)))
```



##### Exercise 2.56

$$
\frac {d(u^n)} {dx} = nu^{n-1}(\frac {du} {dx})
$$

```lisp
(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

; ** 2 n
(define (** base exponent)
  (expt base exponent))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base x) (cadr x))
(define (exponent x) (caddr x))
(define (make-exponent base exponent)
  (cond ((=number? base 0) 0)
        ((=number? exponent 0) 1)
        ((and (number? base) (number? exponent)) (** base exponent))
        (else (list '** base exponent))))

(define (deriv exp var)
  (cond ((number? exp) 0)
    ((variable? exp)
     (if (same-variable? exp var) 1 0))
    ((exponentiation? exp)
     (make-product
      (make-product (exponent exp) (make-exponent (base exp) (- (exponent exp) 1)))
      (deriv (base exp) var)))
    (else
     (error "unknown expression type -- DERIV" exp))))

(deriv '(** x 8) 'x)
; '(* 8 (** x 7)) 
```

